    chai = require 'chai'
    chai.should()
    path = require 'path'
    FS = require '..'
    delay = (timeout) -> new Promise (resolve) -> setTimeout resolve, timeout
    uuid = require 'uuid'
    pkg = require '../package'
    debug = (require 'debug') "#{pkg.name}:test:0001"
    EventEmitter = require 'events'

    util = require 'util'
    process.on 'unhandledRejection', (reason,p) ->
      console.error "unhandledRejection on #{util.inspect reason} for #{util.inspect p}"

We start two FreeSwitch docker.io instances, one is used as the "client" (and is basically our SIP test runner), while the other one is the "server" (and is used to test the `server` side of the package).

    client_port = 8024
    server_port = 8022

FreeSwitch SIP domain.

    domain = '127.0.0.1:5062'

On my laptop I can only get up to 14 cps with the two FreeSwitch instances running. Will need to characterise what is sustainable on travis-ci.

    cps = 2
    second = 1000

    do_show_stats = false

`leg_progress_timeout` counts from the time the INVITE is placed until a progress indication (e.g. 180, 183) is received. Controls Post-Dial-Delay on this leg.

leg_timeout restrict the length of ringback, à la bridge_answer_timeout


FIXME: conversion in general terms is more complex, value may contain comma, quote, etc.

    options_text = (options) -> ("#{key}=#{value}" for key, value of options).join ','

    timer = ->
      now = new Date()
      ->
        new Date() - now

This flag is used to hide extraneous messages (esp. benchmark data) during regular tests.

Test of the `client` part
=========================

    describe 'The client image', ->

        it 'should be reachable', (done) ->
          client = FS.client ->
            client.end -> done()
          .connect client_port, '127.0.0.1'

        it 'should report @once errors', (done) ->
          client = FS.client ->
            client.call.on 'socket.error', (err) ->
              debug "Error #{err}"
              done()
            client.end ->
              client.call.send 'catchme'
                .then ->
                  done new Error 'Should not be successful'
                .catch -> yes

          client.connect client_port, '127.0.0.1'

        it 'should detect login errors', (done) ->
          client = FS.client ->
            done new Error 'Should not reach here'
          client.call.removeAllListeners 'freeswitch_auth_request'
          client.call.onceAsync 'freeswitch_auth_request'
            .then ->
              @auth 'barfood'
            .catch (error) ->
              client.end -> done()
          client.connect client_port, '127.0.0.1'

        it 'should report login errors', (done) ->
          client = FS.client password:'barfood', ->
            client.end()
          , -> done()
          client.connect client_port, '127.0.0.1'

        it 'should report login errors (default_password)', (done) ->
          FS.default_password = 'barfood'
          client = FS.client ->
            client.end()
          , ->
            done()
            FS.default_password = 'ClueCon'
          client.connect client_port, '127.0.0.1'

        it 'should reloadxml', (done) ->
          cmd = 'reloadxml'
          client = FS.client ->
            @api cmd
            .then (res) ->
              res.body.should.match /\+OK \[Success\]/
              this
            .then -> client.end()
            .then -> done()
          .connect client_port, '127.0.0.1'

        it 'should properly parse plain events', (done) ->
          @timeout 2000
          cmd = 'event plain ALL'
          client = FS.client ->
            @onceAsync 'CUSTOM'
            .then (msg) ->
              msg.body.should.have.property 'Event-Name', 'CUSTOM'
              msg.body.should.have.property 'Event-XBar', 'some'
              null
            .then done
            .catch done
            @send cmd
            .then (res) ->
              res.headers['Reply-Text'].should.match /\+OK event listener enabled plain/
              @sendevent 'foo', 'Event-Name':'CUSTOM', 'Event-XBar':'some'
            .delay 1000
            .then -> @exit()
            .then -> client.end()
          .connect client_port, '127.0.0.1'

        it 'should properly parse JSON events', (done) ->
          @timeout 2000
          cmd = 'event json ALL'
          client = FS.client ->
            @onceAsync 'CUSTOM'
            .then (msg) ->
              msg.body.should.have.property 'Event-Name', 'CUSTOM'
              msg.body.should.have.property 'Event-XBar', 'ë°ñ'
              null
            .then done
            .catch done
            @send cmd
            .then (res) ->
              res.headers['Reply-Text'].should.match /\+OK event listener enabled json/
              @sendevent 'foo', 'Event-Name':'CUSTOM', 'Event-XBar':'ë°ñ'
            .delay 1000
            .then -> @exit()
            .then -> client.end()
          .connect client_port, '127.0.0.1'

FIXME re-write another test that actually detects that the call went to FreeSwitch but the socket was unavailable on the back-end.

        it 'should detect failed socket', (done) ->

          @timeout 1000

          client = FS.client ->
            duration = timer()
            @api "originate sofia/test-client/sip:server-failed@127.0.0.1:34564 &park"
            .catch (error) ->
              error.should.have.property 'args'
              error.args.should.have.property 'reply'
              error.args.reply.should.match /^-ERR NORMAL_TEMPORARY_FAILURE/
              client.end -> done()
            .catch done

          client.connect client_port, '127.0.0.1'

    describe 'The server image', ->

        it 'should be reachable', (done) ->
          client = FS.client ->
            client.end -> done()
          client.connect server_port, '127.0.0.1'
          return

        it 'should reloadxml', (done) ->
          cmd = 'reloadxml'
          client = FS.client ->
            @api cmd
            .then (res) ->
              res.body.should.match /\+OK \[Success\]/
              this
            .then -> client.end -> done()
            .catch done
          .connect server_port, '127.0.0.1'

Tests of the `server` part
==========================

Server startup and connectivity
-------------------------------

    describe 'The server', ->

This is really a basic test to make sure the infrastructure is running.

      server = null

We start one server

      ev = new EventEmitter

      before (done) ->

        service = ->

          destination = @data.variable_sip_req_user

          debug 'destination', destination

          switch destination
            when  'answer-wait-3020'
              await @command 'answer'
              await delay 3000
              await @command('hangup').catch -> debug 'caught in answer-wait-3020'

            when 'server7002'
              res = await @command 'answer'
              res.body['Channel-Call-State'].should.eql 'ACTIVE'
              await @command('hangup').catch -> debug 'caught in server7002'
              ev.emit 'server7002'

            when 'server7003'
              res = await @command 'answer'
              res.body['Channel-Call-State'].should.eql 'ACTIVE'
              await @command('hangup').catch -> debug 'caught in server7003'
              ev.emit 'server7003'

            when 'server7008'
              @once 'cleanup_linger', =>
                ev.emit 'server7008'
                @end()
              await @linger()
              await @command 'answer'
              await delay 1000
              await @command('hangup').catch -> debug 'caught'

            else
              done new Error "Invalid destination #{destination}"

          await @end()
          debug 'done'

        server = FS.server all_events: no, -> service.call(this).catch done
        server.on 'listening', ->
          setTimeout done, 1*second
        server.listen 7000
        null

      after (done) ->
        @timeout 10*second
        check = ->
          server.getConnections (err,count) ->
            if count > 0
              done new Error "Oops, #{count} active connections leftover"
              return
            server.close ->
              debug 'server closed'
              done()
        setTimeout check, 8*second
        null

      it 'should handle one call', (done) ->

          @timeout 5000

          ev.on 'server7002', ->
            client.end -> delay(3500).then -> done()

          client = FS.client ->
            @api "originate sofia/test-client/sip:server7002@#{domain} &bridge(sofia/test-client/sip:answer-wait-3020@#{domain})"
            .catch (error) ->
              done error
          client.connect client_port, '127.0.0.1'
          null

      it 'should handle one call (bgapi)', (done) ->

          @timeout 4000

          ev.on 'server7003', ->
            client.end -> delay(3500).then -> done()

          client = FS.client ->
            @bgapi "originate sofia/test-client/sip:server7003@#{domain} &bridge(sofia/test-client/sip:answer-wait-3020@#{domain})"
            .catch (error) ->
              console.log error
          client.connect client_port, '127.0.0.1'
          null

The `exit` command normally triggers automatic cleanup for linger
-----------------------------------------------------------------

Automatic cleanup should trigger a `cleanup_linger` event if we're using linger mode.

      it 'should linger on exit', (done) ->

          @timeout 4000

          ev.on 'server7008', ->
            client.end -> delay(3500).then -> done()

          client = FS.client ->
            @api "originate sofia/test-client/sip:server7008@#{domain} &hangup"
            .catch done
          client.connect client_port, '127.0.0.1'
          null

Client and server interaction
-----------------------------

These tests are long-runners.

    describe 'The client', ->

        server = null

        before (done) ->

          service = ->

            destination = @data.variable_sip_req_user

            debug 'destination', destination

            switch destination

              when  'answer-wait-15000'
                await @command 'answer'
                await delay 15000
                await @command('hangup').catch -> debug 'caught'

              when  'answer-wait-3000'
                debug 'answer'
                await @command 'answer'
                await delay 3000
                await @command('hangup').catch -> debug 'caught'
                debug 'hung up'

              else
                debug "Invalid destination #{destination}"
                throw new Error "Invalid destination #{destination}"

            debug 'service done'

          server = FS.server all_events:no, -> service.call(this).catch done
          server.on 'listening', ->
            done()
          server.listen 7000
          null

        after (done) ->
          @timeout 10*second
          check = ->
            server.getConnections (err,count) ->
              if count > 0
                done new Error "Oops, #{count} active connections leftover"
                return
              server.close ->
                debug 'server closed'
                done()
          setTimeout check, 8*second
          null

        it 'should connect a single call', (done) ->
          @timeout 17*second

          client = FS.client ->
            id = uuid.v4()
            options =
              leg_progress_timeout: 1
              leg_timeout: 2
              tracer_uuid: id
            duration = timer()
            @once 'CHANNEL_HANGUP', (msg) ->
              debug 'CHANNEL_HANGUP'
              if msg.body?.variable_tracer_uuid is id
                duration().should.be.above 14*second
                duration().should.be.below 16*second
                client.end()
                done()
            @event_json 'CHANNEL_HANGUP'
            .then ->
              @api "originate [#{options_text options}]sofia/test-client/sip:answer-wait-15000@#{domain} &park"
            .catch done
          .connect client_port, '127.0.0.1'

This is a simple test to make sure the client can work with both legs.

        it 'should work with simple routing', (done) ->

          count = 40

          @timeout 8000*count/cps

          caught_client = 0
          sent = 0
          done_called = false
          new_call = ->
            client = FS.client ->
              @api "originate sofia/test-client/sip:answer-wait-3000@#{domain} &bridge(sofia/test-client/sip:answer-wait-3000@#{domain})"
              .then ->
                sent += 2
                debug "Sent #{sent}"
              .delay 4000
              .then ->
                client.end ->
                  if sent/2 is count and not done_called
                    done_called = true
                    delay 2*4000
                    .then -> done()
              .catch (error) ->
                debug "Error #{error}"
                caught_client++
                debug "Caught #{caught_client} client errors."
            .connect client_port, '127.0.0.1'

          for i in [1..count]
            setTimeout new_call, i*second/cps

          if do_show_stats
            show_stats = ->
              debug "Sent #{ if show_stats.sent then sent - show_stats.sent else sent} (totals: #{sent})"
              show_stats.sent = sent
            for i in [1..15]
              setTimeout show_stats, i*second

Next test the server at 2*cps call setups per second.

    describe 'Our server', ->

        server = null

        caught = 0
        server3 = stats:
          received: 0
          answered: 0
          completed: 0
        server1 = stats:
          received: 0
          answered: 0
          completed: 0
        server2 = stats:
          received: 0
          answered: 0
          completed: 0
        db = null

We implement a small LCR database using PouchDB.

        caught = 0

        ev = new EventEmitter

        before (done) ->

          PouchDB = require 'pouchdb-core'
            .plugin require 'pouchdb-adapter-memory'
            .defaults adapter: 'memory'
          db = new PouchDB 'routes'

          db.bulkDocs [
            {_id:'route:', comment:'default', target:'324343'}
            {_id:'route:1', comment:'NANPA', target:'37382'}
            {_id:'route:1435', comment:'some state', target:'738829'}
          ]

          service = ->

            destination = @data.variable_sip_req_user

            debug 'destination', destination

            if destination.match /^lcr7010-\d+$/
              server3.stats.received++
              @once 'freeswitch_disconnect', ->
                server3.stats.completed++

The server builds a list of potential route entries (starting with longest match first)

              dest = destination.match(/^lcr\d+-(\d+)$/)[1]
              ids = ("route:#{dest[0...l]}" for l in [0..dest.length]).reverse()

and these are retrieved from the database.

              debug 'Retrieve', ids

              db.allDocs keys:ids, include_docs: true
              .then ({rows}) =>

The first successful route is selected.

                doc = (row.doc for row in rows when row.doc?)[0]
                if doc?
                  @command "bridge sip:answer-wait-3000-#{doc.target}@#{domain}"
                else
                  debug "No route for #{dest}"
                  @hangup().catch -> true
              .catch (error) ->
                caught++
                debug "Error #{error}"
                debug "Caught #{caught} errors."

              return

            if destination.match /^answer-wait-3000-\d+$/
              await @command('hangup').catch -> debug 'caught'
              return

            switch destination

              when  'answer-wait-3050'
                await @command 'answer'
                await delay 3050
                await @command('hangup').catch -> debug 'caught'

              when 'server7022'
                await @command 'set', 'a=2'
                await @command 'set', 'b=3'
                await @command 'set', 'c=4'
                await @exit()
                ev.emit 'server7022'

              when 'server7004'
                server1.stats.received++

The call is considered completed if FreeSwitch properly notified us it was disconnecting.
This might not mean the call was successful.

                @once 'freeswitch_disconnect', ->
                  server1.stats.completed++

                @command 'answer'
                .then (res) ->
                  res.body['Channel-Call-State'].should.eql 'ACTIVE'
                  server1.stats.answered++
                .delay 3000
                .then -> @hangup().catch -> true
                .catch (error) ->
                  caught++
                  debug "Error #{error}"
                  debug "Caught #{caught} errors."

              when 'server7006'
                server2.stats.received++
                @once 'freeswitch_disconnect',
                  server2.stats.completed++
                @command 'answer'
                .then (res) ->
                  res.body['Channel-Call-State'].should.eql 'ACTIVE'
                  server2.stats.answered++
                .catch (error) ->
                  caught++
                  debug "Error #{error}"
                  debug "Caught #{caught} errors."

              else
                throw new Error "Invalid destination #{destination}"

            debug 'done'

          server = FS.server all_events:no, -> service.call(this).catch done
          server.on 'listening', ->
            done()
          server.listen 7000
          null

        after (done) ->
          @timeout 10*second
          check = ->
            server.getConnections (err,count) ->
              if count > 0
                done new Error "Oops, #{count} active connections leftover"
                return
              server.close ->
                debug 'server closed'
                done()
          setTimeout check, 8*second
          null

        it 'should handle many calls', (done) ->

          count = 20

          @timeout count/cps*second+7000

          caught_client = 0
          sent = 0
          new_call = ->
            client = FS.client ->
              @api "originate sofia/test-client/sip:server7004@#{domain} &bridge(sofia/test-client/sip:server7006@#{domain})"
              .then ->
                sent += 2
              .delay 500
              .then -> client.end()
              .catch ->
                caught_client++
                debug "Caught #{caught_client} client errors."
            .connect client_port, '127.0.0.1'

          for i in [1..count]
            setTimeout new_call, i*second/cps

          show_stats = ->
            debug "Sent #{ if show_stats.sent then sent - show_stats.sent else sent}, answered1 #{ if show_stats.answered1 then server1.stats.answered - show_stats.answered1 else server1.stats.answered } completed #{ if show_stats.completed1 then server1.stats.completed - show_stats.completed1 else server1.stats.completed } answered2 #{ if show_stats.answered2 then server2.stats.answered - show_stats.answered2 else server2.stats.answered } completed2 #{ if show_stats.completed2 then server2.stats.completed - show_stats.completed2 else server2.stats.completed } (totals: #{sent}/#{server1.stats.answered}/#{server1.stats.completed}/#{server2.stats.answered}/#{server2.stats.completed})"
            show_stats.sent = sent
            show_stats.answered1 = server1.stats.answered
            show_stats.completed1 = server1.stats.completed
            show_stats.answered2 = server2.stats.answered
            show_stats.completed2 = server2.stats.completed

Success criteria is that we received disconnect notifications from FreeSwitch for all calls.
This might fail for example because FreeSwitch runs out of CPU and starts sending 503 (max-cpu) errors back, meaning the client is unable to send all calls through up to our servers.

            if sent/2 >= count and server1.stats.completed >= count/2 and server2.stats.completed >= count/2
              if not show_stats.done
                delay 4000
                .then -> done()
              show_stats.done = true
          for i in [1..6+count/cps]
            setTimeout show_stats, i*second

Minimal LCR
-----------

        it 'should do LCR', (done) ->

          count = 20

          @timeout count/cps*second+9000

          caught_client = 0
          sent = 0
          new_call = ->
            client = FS.client ->

The client then calls using a predefined number, the call should be routed.
FIXME: extend the test to provide a list of successful and unsuccessful numbers and make sure they are routed / not routed accordingly.
NOTE: This test and many others are done in the [`tough-rate`](https://github.com/shimaore/tough-rate/blob/master/test/call_server.coffee.md#server-unit-under-test) module.

              @api "originate sofia/test-client/sip:answer-wait-3050@#{domain} &bridge(sofia/test-client/sip:lcr7010-362736237@#{domain})"
              .then ->
                sent += 2
              .delay 500
              .then -> client.end()
              .catch ->
                caught_client++
                debug "Caught #{caught_client} client errors."
            .connect client_port, '127.0.0.1'

          for i in [1..count]
            setTimeout new_call, i*second/cps

          show_stats = ->
            debug "Sent #{sent}, completed #{server3.stats.completed}"
            if sent/2 >= count and server3.stats.completed >= count/2
              if not show_stats.done
                done()
              show_stats.done = true
          for i in [1..2+count/cps]
            setTimeout show_stats, i*second

Multiple, chained commands
==========================

        it 'should handle chained commands', (done) ->

          @timeout 2000

          ev.on 'server7022', ->
            client.end -> done()

          client = FS.client ->
            @event_json 'ALL'
            .then ->
              @api "originate sofia/test-server/sip:server7022@#{domain} &park"
            .catch -> true
          .connect server_port, '127.0.0.1'

Using UUID
----------

    describe 'UUID usage in client mode', ->

      server = null

      before (done) ->

        service = ->

          destination = @data.variable_sip_req_user

          debug 'destination', destination

          switch destination

            when  'answer-wait-30000'
              await @command 'answer'
              await delay 30000

            else
              done new Error "Invalid destination #{destination}"

          debug 'done'

        server = FS.server all_events:no, -> service.call(this).catch done
        server.on 'listening', ->
          done()
        server.listen 7000
        null

      after (done) ->
        @timeout 10*second
        check = ->
          server.getConnections (err,count) ->
            if count > 0
              done new Error "Oops, #{count} active connections leftover"
              return
            server.close ->
              debug 'server closed'
              done()
        setTimeout check, 8*second
        null

      it 'should handle UUID-based commands', (done) ->

            @timeout 2000

            client = FS.client ->
              call_uuid = null
              @event_json 'ALL'
              .then ->
                @api "originate sofia/test-server/sip:answer-wait-30000@#{domain} &park"
              .then (res) ->
                res.should.have.property 'uuid'
                call_uuid = res.uuid
              .delay 1000
              .then ->
                @command_uuid call_uuid, 'hangup'
              .then (res) ->
                res.body['Hangup-Cause'].should.eql 'NORMAL_CLEARING'
                null
              .then ->
                client.end -> done()
              .catch (error) ->
                debug 'caught', error
                done error
            .connect server_port, '127.0.0.1'

      it 'should map sequential responses', (done) ->

            client = FS.client ->
              uuid_1 = null
              uuid_2 = null
              @api "create_uuid"
              .then (res) ->
                uuid_1 = res.body
              .catch done
              .then ->
                @api "create_uuid"
              .then (res) ->
                uuid_2 = res.body
              .catch done
              .then ->
                client.end ->
                  if uuid_1 is uuid_2
                    done new Error "UUIDs should be unique"
                  else
                    done()
              .catch done
            .connect server_port, '127.0.0.1'

      it 'should map sequential responses (using bgapi)', (done) ->

            client = FS.client ->
              uuid_1 = null
              uuid_2 = null
              @bgapi "create_uuid"
              .then (res) ->
                uuid_1 = res.body
              .catch done
              .then ->
                @bgapi "create_uuid"
              .then (res) ->
                uuid_2 = res.body
              .catch done
              .then ->
                client.end ->
                  if uuid_1 is uuid_2
                    done new Error "UUIDs should be unique"
                  else
                    done()
              .catch done
            .connect server_port, '127.0.0.1'

      it 'should map sequential responses (using queue)', (done) ->

            client = FS.client ->
              uuid_1 = null
              uuid_2 = null
              @api "create_uuid"
              .then (res) ->
                uuid_1 = res.body
              .catch done

              @api "create_uuid"
              .then (res) ->
                uuid_2 = res.body
              .catch done

              @__queue.then ->
                client.end ->
                  switch
                    when not uuid_1?
                      done new Error "Not sequential"
                    when not uuid_2?
                      done new Error "Not sequential"
                    when uuid_1 is uuid_2
                      done new Error "UUIDs should be unique"
                    else
                      done()
              .catch done
            .connect server_port, '127.0.0.1'

      it 'should work with parallel responses (using api)', (done) ->

            client = FS.client ->
              uuid_1 = null
              uuid_2 = null
              p1 = @api "create_uuid"
                .then (res) ->
                  uuid_1 = res.body
                .catch done
              p2 = @api "create_uuid"
                .then (res) ->
                  uuid_2 = res.body
                .catch done
              Promise.all [p1,p2]
              .then ->
                client.end ->
                  switch
                    when not uuid_1?
                      done new Error "Not sequential"
                    when not uuid_2?
                      done new Error "Not sequential"
                    when uuid_1 is uuid_2
                      done new Error "UUIDs should be unique"
                    else
                      done()
              .catch done
            .connect server_port, '127.0.0.1'

      it 'should work with parallel responses (using bgapi)', (done) ->

            client = FS.client ->
              uuid_1 = null
              uuid_2 = null
              p1 = @bgapi "create_uuid"
                .then (res) ->
                  debug 'uuid_1', res
                  uuid_1 = res.body
                .catch done
              p2 = @bgapi "create_uuid"
                .then (res) ->
                  debug 'uuid_2', res
                  uuid_2 = res.body
                .catch done
              Promise.all [p1,p2]
              .then ->
                client.end ->
                  switch
                    when not uuid_1?
                      done new Error "Not sequential"
                    when not uuid_2?
                      done new Error "Not sequential"
                    when uuid_1 is uuid_2
                      done new Error "UUIDs should be unique"
                    else
                      done()
              .catch done
            .connect server_port, '127.0.0.1'

Actually FreeSwitch doesn't generate any error since the command doesn't get executed.
See comment in https://github.com/shimaore/esl/issues/16 : to trigger an error do a `command_uuid(..'play_and_get_digits',...)` and hang up the call before entering any digit.

      it 'should handle errors', (done) ->

            @timeout 2000

            correct = false

            client = FS.client ->
              call_uuid = null
              @event_json 'ALL'
              .then ->
                @api "originate sofia/test-server/sip:answer-wait-30000@#{domain} &park"
              .then (res) ->
                res.should.have.property 'uuid'
                call_uuid = res.uuid
              .then ->
                ref = new Date()
                @command_uuid call_uuid, 'play_and_get_digits', '4 5 3 20000 # silence_stream://4000 silence_stream://4000 choice \\d 1000'
                .then (res) ->
                  now = new Date()
                  duration = now - ref
                  duration.should.be.above 1000
                  duration.should.be.below 1200
                  res.body.should.have.property 'Answer-State', 'hangup'
                  res.body.should.have.property 'Hangup-Cause', 'NO_PICKUP'
                  correct = true
                .catch done
                null
              .delay 1000
              .then ->
                @hangup_uuid call_uuid, 'NO_PICKUP'
              .delay 500
              .then -> client.end -> if correct then done()
              .catch done
            .connect server_port, '127.0.0.1'

Test DTMF
---------

This test should work but I haven't taken the time to finalize it.

      it.skip 'should detect DTMF', (done) ->

          @timeout 9000

          caught = 0
          server = FS.server all_events:no, ->

            @event_json 'DTMF'
            .then ->
              @api 'sofia global siptrace on'
            .then ->
              @command "answer"
            .then ->
              @command "start_dtmf"
            .then ->
                debug 'answered'
                @command 'sleep', 10000
            .catch done
            .delay 10000
            .then -> @exit

          server.listen 7012

          client = FS.client early_trace:true, ->
            @trace on
            channel_uuid = null
            core_uuid = null
            @on 'CHANNEL_OUTGOING', (msg) ->
              core_uuid = msg.body['Unique-ID']
              debug 'CHANNEL_OUTGOING', {core_uuid}

            @event_json 'ALL'
            .then ->
              @api 'sofia status'
            .then ->
              @api 'sofia global siptrace on'
            .then ->
              @api "originate sofia/test-server/sip:server7012@#{domain} &park"
            .then (msg) ->
              channel_uuid = (msg.body.match /\+OK ([\da-f-]+)/)?[1]
              debug 'originate', {channel_uuid}
            .delay 2000
            .then ->
              @api "uuid_send_dtmf #{channel_uuid} 1234"
            .then (msg) ->
              debug 'api', msg
            .delay 5000
            .catch -> true
          .connect server_port, '127.0.0.1'

Test for error conditions
=========================

    describe 'Error conditions: the client', ->

The goal is to document how to detect error conditions, especially wrt LCR conditions.

      server = null

      ev = new EventEmitter

      before (done) ->

        service = ->

          destination = @data.variable_sip_req_user

          switch
            when destination is 'answer-wait-3010'
              await @command 'answer'
              await delay 3010

            when destination is 'wait-24000-ring-ready'
              await delay 24000
              await @command('ring_ready').catch -> true
              await delay 9999

            when m = destination.match /^wait-(\d+)-respond-(\d+)$/
              await delay parseInt m[1]
              await @command 'respond', m[2]
              await delay 9999

            when destination is 'foobared'
              await @command 'respond', 485

            else
              done new Error "Invalid destination #{destination}"

        server = FS.server all_events:no, -> service.call(this).catch done
        server.on 'listening', ->
          done()
        server.listen 7000

      after (done) ->
        @timeout 10*second
        check = ->
          server.getConnections (err,count) ->
            if count > 0
              done new Error "Oops, #{count} active connections leftover"
              return
            server.close ->
              debug 'server closed'
              done()
        setTimeout check, 8*second
        null

The `exit` command must still return a valid response
-----------------------------------------------------

      it 'should receive a response on exit', (done) ->

        client = FS.client ->

          @exit()
          .then (res) ->
            res.headers['Reply-Text'].should.match /^\+OK/
            done()
            client.end()
          .catch done

        client.connect client_port, '127.0.0.1'

The `exit` command normally triggers automatic cleanup
------------------------------------------------------

Automatic cleanup should trigger a `cleanup_disconnect` event.

      it 'should disconnect on exit', (done) ->

        client = FS.client ->

          @once 'cleanup_disconnect', ->
            client.end -> done()

          @exit()
          .catch done

        client.connect client_port, '127.0.0.1'

      it 'should detect invalid syntax', (done) ->

        client = FS.client ->

          @api "originate foobar"
          .catch (error) ->
            error.should.have.property 'args'
            error.args.should.have.property 'reply'
            error.args.reply.should.match /^-USAGE/
            client.end -> done()

        client.connect client_port, '127.0.0.1'

      it 'should detect invalid (late) syntax', (done) ->
        id = uuid.v4()
        options =
          tracer_uuid: id

        client = FS.client ->
          @once 'CHANNEL_EXECUTE_COMPLETE', (res) ->
            res.body.variable_tracer_uuid.should.equal id
            res.body.variable_originate_disposition.should.equal 'CHAN_NOT_IMPLEMENTED'
            client.end -> done()

          @api "originate [#{options_text options}]sofia/test-client/sip:answer-wait-3010@#{domain} &bridge(foobar)"

        client.connect client_port, '127.0.0.1'

      it 'should detect missing host', (done) ->

It shouldn't take us more than 4 seconds (given the value of timer-T2 set to 2000).

        @timeout 4000

The client attempt to connect an non-existent IP address on a valid subnet ("host down").

        client = FS.client ->
          id = uuid.v4()
          options =
            leg_progress_timeout: 8
            leg_timeout: 16
            tracer_uuid: id

          duration = timer()
          @api "originate [#{options_text options}]sofia/test-client/sip:test@172.17.0.42 &park"
          .catch (error) ->
            error.should.have.property 'args'
            error.args.should.have.property 'command'
            error.args.command.should.contain "tracer_uuid=#{id}"
            error.args.should.have.property 'reply'
            error.args.reply.should.match /^-ERR RECOVERY_ON_TIMER_EXPIRE/
            duration().should.be.above 1*second
            duration().should.be.below 3*second
            client.end -> done()
          .catch done

        client.connect client_port, '127.0.0.1'

      it 'should detect closed port', (done) ->

        @timeout 2200

        client = FS.client ->
          id = uuid.v4()
          options =
            leg_progress_timeout: 8
            leg_timeout: 16
            tracer_uuid: id

          duration = timer()
          @api "originate [#{options_text options}]sofia/test-client/sip:test@127.0.0.1:1310 &park"
          .catch (error) ->
            error.should.have.property 'args'
            error.args.should.have.property 'command'
            error.args.command.should.contain "tracer_uuid=#{id}"
            error.args.should.have.property 'reply'
            error.args.reply.should.match /^-ERR NORMAL_TEMPORARY_FAILURE/
            duration().should.be.below 4*second
            client.end -> done()
          .catch done

        client.connect client_port, '127.0.0.1'

      it 'should detect invalid destination', (done) ->

        @timeout 2200

        client = FS.client ->
          id = uuid.v4()
          options =
            leg_progress_timeout: 8
            leg_timeout: 16
            tracer_uuid: id

          @api "originate [#{options_text options}]sofia/test-client/sip:foobared@#{domain} &park"
          .catch (error) ->
            error.should.have.property 'args'
            error.args.should.have.property 'command'
            error.args.command.should.contain "tracer_uuid=#{id}"
            error.args.should.have.property 'reply'
            error.args.reply.should.match /^-ERR NO_ROUTE_DESTINATION/
            client.end -> done()
          .catch done

        client.connect client_port, '127.0.0.1'

      it 'should detect late progress', (done) ->

        @timeout 10000

        client = FS.client ->
          id = uuid.v4()
          options =
            leg_progress_timeout: 8
            leg_timeout: 16
            tracer_uuid: id

          duration = timer()
          @api "originate [#{options_text options}]sofia/test-client/sip:wait-24000-ring-ready@#{domain} &park"
          .catch (error) ->
            error.should.have.property 'args'
            error.args.should.have.property 'reply'
            error.args.reply.should.match /^-ERR PROGRESS_TIMEOUT/
            duration().should.be.above (options.leg_progress_timeout - 1)*second
            duration().should.be.below (options.leg_progress_timeout + 1)*second
            client.end -> done()
          .catch done

        client.connect client_port, '127.0.0.1'

SIP Error detection
===================

      should_detect = (code,pattern) -> (done) ->
        client = FS.client ->
          id = uuid.v4()
          options =
            leg_timeout: 2
            leg_progress_timeout: 16
            tracer_uuid: id

          @on 'CHANNEL_CREATE', (msg) ->
            debug 'CHANNEL_CREATE'
            msg.should.have.property 'body'
            msg.body.should.have.property 'variable_tracer_uuid', id
          @on 'CHANNEL_ORIGINATE', (msg) ->
            debug 'CHANNEL_ORIGINATE'
            msg.should.have.property 'body'
            msg.body.should.have.property 'variable_tracer_uuid', id
          @once 'CHANNEL_HANGUP', (msg) ->
            debug 'CHANNEL_HANGUP'
            msg.should.have.property 'body'
            msg.body.should.have.property 'variable_tracer_uuid', id
            msg.body.should.have.property 'variable_sip_term_status', code
          @on 'CHANNEL_HANGUP_COMPLETE', (msg) ->
            debug 'CHANNEL_HANGUP_COMPLETE', msg?.body?.variable_sip_term_status
            msg.should.have.property 'body'
            msg.body.should.have.property 'variable_tracer_uuid', id
            msg.body.should.have.property 'variable_sip_term_status', code
            msg.body.should.have.property 'variable_billmsec', '0'
            client.end -> done()
          @filter 'variable_tracer_uuid', id
          .then -> @event_json 'ALL'
          .then -> @api "originate {#{options_text options}}sofia/test-client/sip:wait-100-respond-#{code}@#{domain} &park"
          .catch (error) ->
            error.should.have.property 'args'
            error.args.should.have.property 'reply'
            error.args.reply.should.match pattern
            error.should.have.property 'res'
          .catch done

        client.connect client_port, '127.0.0.1'

      @timeout 1000
      # Anything below 4xx isn't an error
      it 'should detect 403', should_detect '403', /^-ERR CALL_REJECTED/
      it 'should detect 404', should_detect '404', /^-ERR UNALLOCATED_NUMBER/
      # it 'should detect 407', should_detect '407', ... res has variable_sip_hangup_disposition: 'send_cancel' but no variable_sip_term_status
      it 'should detect 408', should_detect '408', /^-ERR RECOVERY_ON_TIMER_EXPIRE/
      it 'should detect 410', should_detect '410', /^-ERR NUMBER_CHANGED/
      it 'should detect 415', should_detect '415', /^-ERR SERVICE_NOT_IMPLEMENTED/
      it 'should detect 450', should_detect '450', /^-ERR NORMAL_UNSPECIFIED/
      it 'should detect 455', should_detect '455', /^-ERR NORMAL_UNSPECIFIED/
      it 'should detect 480', should_detect '480', /^-ERR NO_USER_RESPONSE/
      it 'should detect 481', should_detect '481', /^-ERR NORMAL_TEMPORARY_FAILURE/
      it 'should detect 484', should_detect '484', /^-ERR INVALID_NUMBER_FORMAT/
      it 'should detect 485', should_detect '485', /^-ERR NO_ROUTE_DESTINATION/
      it 'should detect 486', should_detect '486', /^-ERR USER_BUSY/
      it 'should detect 487', should_detect '487', /^-ERR ORIGINATOR_CANCEL/
      it 'should detect 488', should_detect '488', /^-ERR INCOMPATIBLE_DESTINATION/
      it 'should detect 491', should_detect '491', /^-ERR NORMAL_UNSPECIFIED/
      it 'should detect 500', should_detect '500', /^-ERR NORMAL_TEMPORARY_FAILURE/
      it 'should detect 502', should_detect '502', /^-ERR NETWORK_OUT_OF_ORDER/
      it 'should detect 503', should_detect '503', /^-ERR NORMAL_TEMPORARY_FAILURE/
      it 'should detect 504', should_detect '504', /^-ERR RECOVERY_ON_TIMER_EXPIRE/
      it 'should detect 600', should_detect '600', /^-ERR USER_BUSY/
      it 'should detect 603', should_detect '603', /^-ERR CALL_REJECTED/
      it 'should detect 604', should_detect '604', /^-ERR NO_ROUTE_DESTINATION/
      it 'should detect 606', should_detect '606', /^-ERR INCOMPATIBLE_DESTINATION/
